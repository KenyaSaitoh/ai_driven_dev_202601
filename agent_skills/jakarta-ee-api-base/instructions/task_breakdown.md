# タスク分解インストラクション

## パラメータ設定

実行前に以下のパラメータを設定する

```yaml
project_root: "ここにプロジェクトルートのパスを入力"
spec_directory: "ここにSPECディレクトリのパスを入力"
output_directory: "ここにタスク出力先のパスを入力（オプション）"
```

* 例
```yaml
project_root: "projects/sdd/bookstore/back-office-api-sdd"
spec_directory: "projects/sdd/bookstore/back-office-api-sdd/specs"
output_directory: "projects/sdd/bookstore/back-office-api-sdd/tasks"
```

注意
* パス区切りはOS環境に応じて調整する（Windows: `\`, Unix/Linux/Mac: `/`）
* 以降、`{project_root}` と表記されている箇所は、上記で設定した値に置き換える

---

## 概要

このインストラクションは、基本設計SPEC（basic_design/）を分析して、複数人が並行して作業できる実装タスクリストを分解・生成するためのものである

重要な方針
* タスクリストは抽象度の高いレベルで作成する
* ソースコードや詳細な実装手順は含めない
* 各タスクは「何を作成・修正するか」を明確に示す
* 詳細な実装は次の「実装フェーズ（コード生成）」でSPECを参照して行う
* タスク分解の結果として、common（共通機能）とAPI単位を識別する
* この識別結果に基づいて、次の詳細設計フェーズで detailed_design/ フォルダ構造を作成する

出力先
* ベースプロジェクトの場合: `{project_root}/tasks/` ディレクトリ
* 拡張の場合: `{spec_directory}/tasks/` ディレクトリ
* 重要: `{project_root}` と `{spec_directory}` は、パラメータで指定した値に置き換える

---

## 1. 設計ドキュメントの分析

パラメータで指定されたプロジェクト情報に基づいて、以下の設計ドキュメントを読み込んで分析する

注意: `{project_root}` は、パラメータで指定されたパスに置き換える。全てのパスはそのプロジェクトルートを基準とした相対パスである

### Agent Skillsルール（最優先で確認）

* @agent_skills/jakarta-ee-api-base/principles/ - Jakarta EE開発の原則、アーキテクチャ標準、品質基準、セキュリティ標準を確認する
  * このフォルダ配下の原則ドキュメントを読み込み、共通ルールを遵守すること
  * 重要: タスク分解においても、ルールドキュメントに記載されたすべてのルールを遵守すること
  * 注意: Agent Skills配下のルールは全プロジェクト共通。プロジェクト固有のルールがある場合は `{project_root}/principles/` も確認すること

### フレームワーク仕様（該当する場合）

* @agent_skills/jakarta-ee-api-base/frameworks/ - フレームワーク固有のSPECやサンプルコードを確認する
  * 特定のフレームワーク（ライブラリ、ツール等）の使用方法、設計パターン、実装例を参照する
  * タスク分解時に、フレームワーク固有の実装要件を考慮する

### 必須ドキュメント（basic_design/配下 - 基本設計SPEC）

* architecture_design.md - 技術スタック、アーキテクチャパターン、ライブラリを確認する
  * アーキテクチャパターンを識別する
  * データ管理方針を確認する
  * 外部連携要件を確認する
* functional_design.md - システム全体の機能設計（全APIを含む）を確認する
  * 全ての機能を分析する
  * 何が共通機能で何がAPI固有機能かを識別する
* data_model.md - テーブル定義とERDを確認する（該当する場合）
* behaviors.md - システム全体の振る舞い（全APIの振る舞いを含む）を確認する
* external_interface.md - 外部連携とAPI仕様を確認する（該当する場合）

注意: 
* 基本設計フェーズでは、api/フォルダやcommon/フォルダはまだ作成されていない
* 全ての機能と振る舞いは basic_design/functional_design.md と basic_design/behaviors.md に記載されている
* タスク分解フェーズで、これらを分析して common と API単位を識別する

---

## 2. タスクファイルの分割構造

* 出力先の決定:
  * ベースプロジェクトの場合: `{project_root}/tasks/` ディレクトリ
  * 拡張の場合: `{spec_directory}/tasks/` ディレクトリ

重要: 
* `{project_root}` は、パラメータで指定されたパスに置き換えてください
* ベースプロジェクトのタスクは `{project_root}/tasks/` に配置
* 拡張のタスクは `{spec_directory}/tasks/` に配置（例: `specs/enhancements/202512_inventory_alert/tasks/`）

複数人が並行して作業できるように、以下のようにタスクファイルを分割して生成してください：

### 2.1 メインタスクリスト

`tasks/tasks.md` （指定された出力先に配置）
* プロジェクト全体の実行順序を示すメインタスクリスト
* 各タスクと担当者割り当ての概要
* 他のタスクファイルへのリンク集
* タスク間の依存関係を明示する

### 2.2 セットアップタスク

`tasks/setup_tasks.md`
* プロジェクト初期化（全員が実行前に1回だけ）
* 開発環境セットアップ
* データベース初期化
* アプリケーションサーバー設定
* ログ設定
* 静的リソース配置

### 2.3 共通機能タスク

`tasks/common_tasks.md`
* 複数機能で共有される共通コンポーネント
* エンティティ: architecture_design.mdとdata_model.mdから実装対象を判断する
* Dao: 実装するエンティティに対応するDaoを作成する
* 共通サービス: 複数APIで使用されるサービス（API固有のServiceは含めない）
* 認証基盤: 認証関連コンポーネント
* 外部API連携: RestClient（複数APIで共有される場合）
* 共通DTO: ErrorResponse、外部API用DTO等
* 共通ユーティリティ
* フィルター/例外ハンドラ

* 重要: 
  * 共通コンポーネントの具体的な内容は、architecture_design.md、functional_design.md、external_interface.mdから判断する
  * API固有のビジネスロジック（Service）は、並行作業を考慮して、API単位タスクに含める

### 2.4 機能別タスク（API単位）

SPECから機能（API）を抽出してタスクファイルを生成：

#### 機能の識別と抽出

1. 機能（API）の識別
   * basic_design/requirements.md、basic_design/functional_design.mdから機能を抽出する
   * 各APIの範囲と責務を分析する
   * API間の依存関係を把握する
   * 何が共通機能で何がAPI固有機能かを識別する

2. タスクファイルの命名規則
   * 基本形式：`tasks/[API_ID]_[API名].md`
   * 例：`API_001_auth.md`、`API_002_books.md`、`API_003_orders.md`
   * 注意: ファイル名はアンダースコア区切りを使用する
   * 注意: タスク分解の時点では、detailed_design/api/ フォルダはまだ作成されていない

3. 各機能タスクファイルの内容
   * API固有のResourceクラス
   * API固有のServiceクラス（このAPIのみで使用されるビジネスロジック）
   * API固有のDaoクラス（該当する場合、このAPIのみで使用されるデータアクセス）
   * API固有のDTO/レスポンスモデル
   * 外部API連携クライアント（このAPIのみで使用される場合）
   * API固有のテストケース
   * 担当者: 1名（API単位で独立して実装可能）

注意: 複数のAPIで共有されるビジネスロジック（共通Service）は、共通機能タスクに含めます。並行作業を考慮して、API固有のServiceはAPI単位タスクに含めます。

4. 機能分割の判断基準
   * 小規模プロジェクト（1-3 API）: 1つの`all_apis.md`にまとめても可
   * 中規模プロジェクト（4-10 API）: API単位でファイル分割
   * 大規模プロジェクト（10+ API）: APIグループごとにディレクトリ分割も検討

### 2.5 結合テストタスク

`tasks/integration_tasks.md`
* API間結合テスト
* E2E APIテスト - 主要な業務フローをAPIシーケンスでテストする
* パフォーマンステスト
* セキュリティテスト
* CORS動作確認（該当する場合）
* 並行処理テスト（該当する場合）
* 最終検証

---

## 3. タスク分解ルール

### 3.1 並行実行の判断基準

* [P]マークを付与する条件（並行実行可能）
  * 異なるファイルを編集するタスク
  * 異なるエンティティの実装
  * 異なるAPIの実装
  * 独立したテストケース

* 順次実行（[P]なし）が必要な条件
  * 同じファイルを編集するタスク
  * 依存関係があるタスク

### 3.2 タスクの粒度

重要: タスクは抽象度の高いレベルで定義し、ソースコードは含めない

各タスクは以下の粒度で分割する
* Entity/Model: 1エンティティクラスの作成/修正
* DTO/Response: 1 DTOまたはレスポンスモデルクラスの作成/修正
* Dao: 1 Daoクラスの作成/修正
* Service: 1 Serviceクラスの作成/修正（複雑な場合は複数タスクに分割）
* Resource: 1 Resourceクラスの作成/修正
* Filter/Interceptor/ExceptionMapper: 1コンポーネントの作成/修正
* RestClient: 1外部API連携クライアントの作成/修正
* Test: 1テストクラスの作成/修正

* 注意: 上記の用語はプロジェクトの技術スタックに応じて読み替える

* タスクの記述レベル
  * 「何を作成・修正するか」を明確に記述する
  * 「どのような機能を実装するか」を簡潔に記述する
  * ソースコードや詳細な実装手順は記述しない
  * 詳細な実装は次の「実装フェーズ（コード生成）」で行う

### 3.3 依存関係の順序付け

以下の順序でタスクを配置する

1. セットアップ (全ての前提)
   * 開発環境構築
   * プロジェクト初期化
   * データベース設定

2. 共通機能 (複数機能で共有)
   * 共通Entity/Model
   * 共通Dao
   * 共通Utility/Helper
   * 共通Service
   * 認証基盤
   * 外部API連携クライアント
   * 共通DTO/Response
   * フィルター/例外ハンドラ

3. 機能別実装（API単位） (並行実行可能)
   * 一般的な実装順序: DTO/Response → Entity → Dao → Service → Resource
   * 各APIは独立して実装可能
   * 注意: 実装順序はプロジェクトのアーキテクチャに従う

4. 結合テスト (全API実装後)
   * API間結合
   * E2E APIテスト - 主要な業務フローベース
   * パフォーマンステスト
   * 並行処理テスト（該当する場合）

---

## 4. タスクファイルのフォーマット

各タスクファイルには以下の情報を含める

### 4.1 ヘッダー情報

```markdown
# [タスクファイル名]

担当者: [想定人数と役割]
推奨スキル: [必要なスキルセット]
想定工数: [時間]
依存タスク: [前提となるタスクファイル]
```

### 4.2 タスクリスト

```markdown
* [ ] [P] タスク X.X.X: [タスク名]
  * 目的: [このタスクで実現する機能・目的]
  * 対象: [作成/修正するコンポーネント名やファイル名]
  * 参照SPEC: [参照するSPEC（Markdownリンク形式）] の「[セクション番号 セクション名]」
  * 注意事項: [考慮すべき点があれば記載]
```

* タスクID命名規則
  * タスクIDはアンダースコア区切りを使用する（例: `T_SETUP_001`, `T_API001_003`）
  * ハイフンは使用しない（例: ~~`T-SETUP-001`~~, ~~`T-API001-003`~~）
  * 形式: `T_[カテゴリ]_[連番]` または `T_[API_ID]_[連番]`

* SPEC参照の記述規則
  * 必須: Markdownリンク形式で記述し、クリックで直接SPECファイルに飛べるようにする
  * 必須: 相対パスを使用する（タスクファイルからSPECファイルへの相対パス）
  * 必須: 具体的なセクション番号とセクション名を明記する
  * 形式: `[ファイル名](相対パス) の「セクション番号 セクション名」`

* 記述例

```markdown
* [ ] T_API002_003: StockDao の作成
  * 目的: 在庫情報の検索・更新機能を実装する
  * 対象: StockDao.java (DAOクラス)
  * 参照SPEC: [functional_design.md](../specs/baseline/api/API_002_stocks/functional_design.md) の「2.2 StockDao」
  * 注意事項: 楽観的ロックに対応したupdate処理を実装すること
```

* 複数SPEC参照の例

```markdown
* [ ] T_API002_006: StockResource の作成
  * 目的: 在庫管理APIエンドポイントを実装する
  * 対象: StockResource.java (JAX-RS Resourceクラス)
  * 参照SPEC: 
    * [functional_design.md](../specs/baseline/api/API_002_stocks/functional_design.md) の「2. エンドポイント仕様」
    * [behaviors.md](../specs/baseline/api/API_002_stocks/behaviors.md) の「2. 在庫API」
  * 注意事項: OptimisticLockException発生時はHTTP 409 Conflictを返すこと
```

注意: ソースコードや詳細な実装手順は記述しない

---

## 5. メインタスクリスト（tasks.md）の構造

`{project_root}/tasks/tasks.md` は以下の構造で生成する

```markdown
# [プロジェクト名] - 実装タスクリスト

## 全体構成と担当割り当て

### タスク概要

| タスク | タスクファイル | 担当者 | 並行実行 | 想定工数 |
|---------|--------------|--------|---------|---------|
| 0. セットアップ | setup_tasks.md | 全員 | 不可 | [分析から算出] |
| 1. 共通機能 | common_tasks.md | 共通機能チーム | 一部可能 | [分析から算出] |
| 2. API_001 | API_001_xxx.md | 担当者A | 可能 | [分析から算出] |
| 3. API_002 | API_002_yyy.md | 担当者B | 可能 | [分析から算出] |
| ... | ... | ... | ... | ... |
| N. 結合テスト | integration_tasks.md | 全員 | 一部可能 | [分析から算出] |

### 実行順序

1. タスク0: セットアップ（全員で実行）
2. タスク1: 共通機能（共通機能チームが実装）
3. タスク2～N-1: API別実装（各担当者が並行実行） ← ここが並行化のポイント
4. タスクN: 結合テスト（全員で実施）

### タスクファイル一覧

* [セットアップタスク](setup_tasks.md)
* [共通機能タスク](common_tasks.md)
* [API_001のタスク](API_001_xxx.md)
* [API_002のタスク](API_002_yyy.md)
* ...
* [結合テストタスク](integration_tasks.md)

## 依存関係図

[Mermaid形式で依存関係を図示]
\```

* 生成時の注意
  * プロジェクト名はrequirements.mdから取得する
  * APIの数、命名、分割方法はSPECから判断する
  * 想定工数は各タスクの複雑度分析から算出する
  * ファイル名はすべてアンダースコア区切りを使用する

---

## 6. 成果物チェックリスト

生成されるタスクファイルが満たすべき要件
* ソースコードや詳細な実装手順を含まず、「何を作成・修正するか」を明確に記述する
* [P]マークで並行実行可能なタスクを明示し、依存関係を明確に記述する
* タスクIDはアンダースコア区切り（例: `T_SETUP_001`）で一意に付与する
* アーキテクチャパターンに応じた適切なコンポーネントを実装する（詳細はarchitecture_design.mdを参照）

---

## 7. 生成手順

1. ルールとSPEC分析: `@agent_skills/jakarta-ee-api-base/principles/` 配下の原則ドキュメントと basic_design/ 配下の全SPECを読み込み、共通ルールと機能全体を把握する
2. アーキテクチャ識別: basic_design/architecture_design.md からアーキテクチャパターンを識別する
3. 機能（API）抽出: basic_design/functional_design.md を分析して、実装が必要なAPIを抽出し、依存関係と共通コンポーネントを識別する
   * 何が共通機能で何がAPI固有機能かを判断する
4. タスク分割: API数に応じた適切なファイル分割方法を決定する
5. タスク構成: basic_design/ のSPECからタスクを抽出し、セットアップ/共通/API別/結合に分類・順序付けする
6. 並行化判定: [P]マークを付与し、タスクファイルを指定された出力先に生成する
7. メインリスト生成: `tasks/tasks.md` に全体概要と実行計画を生成する

重要: 
* タスク分解の結果として、common（共通機能）とAPI単位が識別される
* この識別結果は、次の詳細設計フェーズで detailed_design/ フォルダ構造を作成する際に使用される
* `{project_root}` と出力先はパラメータで指定される。ファイル名・タスクIDは全てアンダースコア区切りを使用する

---

## 8. 重要な注意事項

### 命名規則

* ファイル名・タスクIDは全てアンダースコア区切り（例: `setup_tasks.md`, `T_SETUP_001`）
* ハイフン（`-`）は使用しない

### SPEC参照の記述

全てのタスクの「参照SPEC」は以下の形式で記述する
* Markdownリンク形式でクリック可能にする（例: `[functional_design.md](相対パス)`）
* 具体的なセクション番号とセクション名を明記する（例: `の「2.2 在庫管理機能」`）
* 複数SPEC参照の場合は箇条書きで列挙する
* タスク分解時点では basic_design/ 配下のSPECを参照する
* 注意: detailed_design/ 配下のフォルダは、詳細設計フェーズで作成されるため、タスク分解時点では存在しない

### タスク分解のルール

* ルール遵守: `@agent_skills/jakarta-ee-api-base/principles/` 配下の原則ドキュメント（共通ルール、品質基準、セキュリティ標準、組織標準）を必ず遵守する。プロジェクト固有の原則がある場合は `{project_root}/principles/` も併せて遵守する
* 抽象度の維持: タスクは「何を作るか」のみを記述する。ソースコードや詳細な実装手順は記述しない
* アーキテクチャ適応: basic_design/architecture_design.md からアーキテクチャパターンを識別し、適切なタスクを分解・生成する
* 機能分解: basic_design/functional_design.md を分析して、何が共通機能で何がAPI固有機能かを識別する
* 既存コード考慮: 既存実装がある場合は、修正タスクと新規作成タスクを明確に区別する
* APIテスト設定: E2E APIテストは通常ビルドから除外し、個別実行可能にする設定を明記する

### REST API特有の注意点

* 画面（UI）は含まれないため、View/XHTMLに関するタスクは生成しない
* API エンドポイント（Resource）のテストは REST Assured や JAX-RS Client を使用する
* JWT認証、CORS、HTTPステータスコードの適切な使用を考慮する

### プロジェクトルートの扱い

* `{project_root}` は、パラメータで明示的に指定されたパスに置き換える
* 相対パスでも絶対パスでも構わない
* 全てのファイル操作は、このプロジェクトルートを基準に行う
