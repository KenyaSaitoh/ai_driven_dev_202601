# Struts to JSF マイグレーション共通ルール

バージョン: 1.0.0  
制定日: 2026-01-12  
最終更新日: 2026-01-17

## 概要

このドキュメントは、Apache Struts 1.xからJakarta Faces (JSF)へのマイグレーションを行うすべてのプロジェクトで共通的に適用されるルールと手法を定義する

* 対象移行元: Apache Struts 1.x（Struts 1.3.10等）
* 対象移行先: Jakarta Faces (JSF) 4.0 + Jakarta EE 10
* マイグレーションアプローチ: 仕様駆動マイグレーション（Spec-Driven Migration）

## 仕様駆動開発の基本ルール

### 仕様ファースト開発（Code-to-Spec-to-Code）

直接的なコード変換（Code-to-Code）ではなく、以下の3段階アプローチを採用する：

1. 既存コード分析（仕様書生成）: Strutsコードから抽象的・論理的な仕様書を生成
2. 仕様書の検証と調整: 仕様書をレビューし、JSFアーキテクチャに適応
3. 仕様駆動開発（コード生成）: 仕様書からJSFコードを生成

根拠: 直接的なコード変換は、レガシーな設計パターンや技術的負債を新システムに持ち込むリスクがある
一度仕様書として抽象化することで、アーキテクチャを刷新し、品質の高いシステムを構築できる

### アーキテクチャの刷新

Strutsの古いパターンをそのまま移植するのではなく、Jakarta EE 10の最新ベストプラクティスに従った設計に刷新する

* Strutsの特徴:
  * ActionForm（POJO）
  * Action（コントローラー）
  * EJB 3.2（ステートレスセッションBean、JNDIルックアップ）
  * DAO（JDBC + DataSource）
  * JSPタグライブラリ（`<logic:iterate>`, `<bean:write>`, `<html:form>`等）

* JSFの特徴:
  * Managed Bean（`@Named`, `@ViewScoped`）
  * CDI（`@Inject`、依存性注入）
  * JPA（EntityManager、JPQL）
  * トランザクション（`@Transactional`）
  * Facelets XHTML（`<h:dataTable>`, `<h:outputText>`, `<h:form>`等）

根拠: 最新のアーキテクチャパターンを採用することで、保守性、テスタビリティ、拡張性を向上させる

### テスト駆動品質

マイグレーション後のシステムが、元のシステムと同等の機能を持つことを、テストで検証する

根拠: テストによって、マイグレーションの正確性を保証する

### ドキュメント品質の追求

生成する仕様書は、以下を含む完全なものとする：

* requirements.md: システムの目的、機能要件、非機能要件
* architecture_design.md: 技術スタック、レイヤー構成、パッケージ構造
* functional_design.md: 画面一覧、画面遷移、コンポーネント設計
* data_model.md: エンティティ、テーブル定義、リレーション
* screen_design.md: 画面レイアウト、入力項目、ボタンアクション
* behaviors.md: 画面の振る舞い、バリデーション、エラーハンドリング

根拠: 完全な仕様書がなければ、仕様駆動開発で機能が欠落するリスクがある

## マイグレーション固有ルール

### ビジネスロジックの保全

UI技術やデータアクセス技術は変更するが、ビジネスロジックとビジネスルールは可能な限り保全する

根拠: ビジネスロジックは組織の資産であり、フレームワーク移行によって失われてはならない

### 段階的マイグレーション

大規模システムの場合、一度に全体をマイグレーションするのではなく、機能単位で段階的にマイグレーションする

根拠: リスクを最小化し、各段階で検証とフィードバックを得ることができる

### マッピングの明示化

Strutsの構成要素とJSFの構成要素のマッピングを明示的に文書化する

根拠: マッピングを明確にすることで、マイグレーションの一貫性と品質を保証する

注記: 具体的なマッピング方法は、各インストラクション（reverse_engineering.md、code_generation.md等）を参照すること

### データモデルの継続性

データベーススキーマは基本的に変更しない
既存のテーブル構造をそのまま使用する

根拠: データベーススキーマ変更は大きなリスクを伴う
マイグレーションの範囲をアプリケーション層に限定することで、リスクを最小化する

## Markdownフォーマット規約

すべての生成される仕様書ドキュメントは以下のフォーマット規約に従う：

* 箇条書きはアスタリスク（`*`）を使用する
  * ハイフン（`-`）は使用しない
  * 一貫性を保つため、すべての箇条書きで統一する
* 箇条書きは必要に応じてネストする
  * 親項目が「項目名:」で終わる場合、その配下の項目は2スペースインデントする
  * ネストは意味的なグループ化を明確にする
* ボールド（太字）は使用しない
  * 見出しレベル（`#`、`##`、`###`等）で構造化する
  * 強調が必要な場合は、箇条書きや見出しで表現する
* コード例の前には箇条書き形式で説明を記載する
  * 例: `* Java:`の後にコードブロック

根拠: 統一されたフォーマットにより、可読性が向上し、ドキュメントの保守性が高まる

## タスクの完遂責任

開始したタスクは、中断せず最後まで完遂する
すべてのステップ（仕様書生成、検証、コード生成、テスト作成）を完了させてから終了する

根拠: 途中で停止すると、不完全な状態のままタスクが残り、プロジェクトの進捗に悪影響を与える
一度開始したタスクは責任を持って完了させることで、品質と生産性を保証する

## 参考資料

* [Jakarta EE 10仕様](https://jakarta.ee/specifications/platform/10/)
* [Jakarta Faces 4.0仕様](https://jakarta.ee/specifications/faces/4.0/)
* [Apache Struts 1.x Documentation](https://struts.apache.org/struts1eol-announcement.html)
