# コード生成インストラクション

## 使用方法

```
@instructions/generate_code.md このインストラクションに従って、
プロジェクトルート: @<プロジェクトルートのパス>
タスクリスト: @<タスクファイルのパス>
に基づいて実装を進めてください。
```

---

## 実装の実行

**重要: 指定されたタスクファイルのタスクのみを実行し、完了したら停止してください。次のタスクに自動的に進んではいけません。**

現在の機能コンテキストに基づいて、以下を実行してください：

1. 実装コンテキストをロードして分析してください：
   - **最優先**: `<プロジェクトルート>/memory/` 配下の憲章ファイルでプロジェクトの開発原則、アーキテクチャ方針、品質基準、組織標準を確認
   - **必須**: 指定されたタスクリストで完全なタスクリストと実行計画を確認
     - タスクの「参照SPEC」はMarkdownリンク形式で記述されています（クリック可能）
     - リンク先のSPECファイルと指定されたセクションを必ず参照してください
   - **必須**: architecture_design.md で以下を確認：
     - 技術スタック（言語、バージョン、フレームワーク、ライブラリ）
     - アーキテクチャパターンとレイヤー構成
     - パッケージ構造と命名規則
     - デザインパターン、トランザクション戦略、並行制御
     - ログ戦略、エラーハンドリング、セキュリティ
     - テスト戦略（テストフレームワーク、カバレッジ目標、テスト方針）
     - **コード生成時は、ここで定義された技術スタックを厳密に遵守すること**
   - **必須**: requirements.md で機能要件と成功基準を確認
   - **必須**: functional_design.md でクラス設計、メソッド、機能フローを確認
   - **存在する場合**: data_model.md（データモデル仕様書）でエンティティと関係を確認
   - **存在する場合**: screen_design.md（画面仕様書）でUI設計とレイアウト仕様を確認
   - **存在する場合**: behaviors.md（振る舞い仕様書）で受入基準とテストシナリオを確認
   - **存在する場合**: external_interface.md（外部インターフェース仕様書）で外部連携仕様とAPI仕様（OpenAPI YAML含む）を確認
   - **画像リソース**: `<プロジェクトルート>/images/` フォルダ（特に images/covers/）の画像ファイルを確認し、セットアップ時に適切な場所にコピー
   
   **注意**: プロジェクトルートは外部から明示的に指定されます。全てのパスはそのプロジェクトルートを基準とした相対パスです。

2. tasks.md構造を解析して抽出してください：
   - **タスク構成**: セットアップ、共通機能、機能別実装、結合・テスト
   - **タスク依存関係**: 順次実行対並列実行ルール
   - **タスク詳細**: ID、説明、ファイルパス、並列マーカー[P]
   - **実行フロー**: 順序と依存関係の要件

3. タスク計画に従って実装を実行してください：
   - **タスクごとの実行**: 次のタスクに進む前に各タスクを完了
   - **セットアップタスク**: リソース配置（画像ファイルのコピー等）を最優先で実行
   - **依存関係の尊重**: 順次タスクは順番に実行、並列タスク[P]は一緒に実行可能
   - **TDDアプローチに従う**: 対応する実装の前にテストを実行
   - **ファイルベースの調整**: 同じファイルに影響するタスクは順次実行必須
   - **検証チェックポイント**: 進む前に各タスクの完了を検証

4. 実装実行ルール：
   - **プロジェクトルートの明示**: プロジェクトルートは外部から明示的に指定されます。全てのパス操作はこのプロジェクトルートを基準に行います
   
   - **技術スタックの遵守**: architecture_design.mdに記載された技術スタックを厳密に遵守
     - **プログラミング言語**: architecture_design.mdの「1.1 コアプラットフォーム」を確認（例: Java 21, Jakarta EE 10等）
     - **フレームワーク**: architecture_design.mdの「1.2 Jakarta EE仕様」を確認（例: Jakarta Faces 4.0, JPA 3.1等）
     - **ライブラリとバージョン**: architecture_design.mdの「1.3 追加ライブラリ」を確認（例: SLF4J, Log4j2等）
     - **テストフレームワーク**: architecture_design.mdの「13. テスト戦略」を確認（例: JUnit 5, Mockito, Playwright等）
     - **データベース**: architecture_design.mdの「10. データベース構成」を確認（例: HSQLDB, コネクションプール設定等）
     - **記載されたバージョン番号を正確に使用**: 異なるバージョンを使用しない
   
   - **憲章の遵守**: `<プロジェクトルート>/memory/` 配下の憲章に記載された開発原則を全ての実装で遵守
     - テストカバレッジ基準、アーキテクチャパターン、コーディング規約に従う
     - 品質基準、セキュリティ要件、パフォーマンス基準を満たす
   - **セットアップ優先**: プロジェクト構造、依存関係、構成を初期化
     - **画像リソースの配置**: `<プロジェクトルート>/images/covers/` の全ての画像ファイルを `<プロジェクトルート>/src/main/webapp/resources/covers/` にコピー
     - 必須画像: no-image.jpg（画像が存在しない書籍用のデフォルト画像）
     - 画像ファイル名は書籍名と対応（例: "Java SEディープダイブ.jpg"）
   - **コードの前にテスト**: 契約、エンティティ、結合シナリオのテストを作成（TDDの場合）
   - **コア開発**: モデル、サービス、CLIコマンド、エンドポイントを実装
   - **結合作業**: データベース接続、ミドルウェア、ロギング、外部サービス
   - **仕上げと検証**: ユニットテスト、パフォーマンス最適化、ドキュメント
   
   - **単体テスト生成ガイドライン**:
     - **テストフレームワーク**: architecture_design.mdの「13. テスト戦略」で指定されたフレームワークを使用（例: JUnit 5, Mockito）
     - **テストカバレッジ**: architecture_design.mdの「13.2 テストカバレッジ」の目標値を遵守（例: サービスレイヤー80%以上）
     - behaviors.mdの各Given-When-Thenシナリオから対応するテストケースを抽出して実装
     - functional_design.mdの各メソッドシグネチャに対して、正常系・異常系・境界値のテストを作成
     - data_model.mdのエンティティ検証ルール（制約条件、バリデーション、一意性制約）をテストで検証
     - テストデータはbehaviors.mdやfunctional_design.mdの具体例を参考に作成
     - モックやスタブが必要な場合は、architecture_design.mdの「13.3 テスト方針」に従う
   
   - **E2Eテスト生成ガイドライン**:
     - **E2Eテストフレームワーク**: architecture_design.mdの「1.3 追加ライブラリ」と「13. テスト戦略」で指定されたPlaywrightを使用
     - **テスト対象ブラウザ**: architecture_design.mdの「13.3 テスト方針」を確認（例: Chromium, Firefox, WebKit）
     - screen_design.mdの画面遷移図（Mermaid形式）を参照して主要な画面遷移フローをテスト化
     - 画面遷移図の各パス（ログイン → 検索 → カート → 注文 → 履歴等）をテストケースとして作成
     - 各画面のUI要素（ボタン、入力フィールド、リンク等）の存在確認と操作を実装
     - behaviors.mdのエラーシナリオ（在庫不足、認証エラー等）も画面レベルで検証
     - スクリーンショット取得機能を含め、視覚的な確認も可能にする
     - テストは`src/test/java/<パッケージ>/e2e/`配下に配置（パッケージはarchitecture_design.mdの「4. パッケージ構造」を参照）
     - Playwright Java APIを使用してブラウザ自動化を実装
     - **ビルド時の除外設定**: E2Eテストは通常のビルド（`./gradlew test`）では実行されず、個別に実行する設定にする
       - JUnit 5の`@Tag("e2e")`アノテーションをE2Eテストクラスに付与
       - Gradleの`build.gradle`で、testタスクから"e2e"タグを除外する設定を追加
       - E2E専用のGradleタスク（例: `e2eTest`）を定義し、個別実行可能にする
       - テストクラス名の命名規則で識別可能にする（例: `*E2ETest.java`パターン）

5. コンポーネント別の参照ドキュメント優先度と使用方法：
   
   **重要**: 全てのコンポーネント生成時に、architecture_design.mdの以下を参照すること：
   - **言語・バージョン**: 「1.1 コアプラットフォーム」（Java 21等）
   - **パッケージ配置**: 「4.1 パッケージ編成」
   - **命名規則**: 「4.2 命名規則」
   - **アノテーション**: 「1.2 Jakarta EE仕様」と「5. 状態管理」（@Entity, @Named, @Inject等）
   - **ログ出力**: 「11. ログ戦略」（SLF4J使用、ログレベル、出力方針）
   
   **Entity/Model生成時**:
   - **技術スタック**: architecture_design.mdの「1.2 Jakarta EE仕様」でJakarta Persistence（JPA）バージョンを確認
   - **第一参照**: data_model.md
     - テーブル構造、カラム定義、データ型、制約条件（NOT NULL, UNIQUE等）を確認
     - エンティティ間の関係（OneToMany, ManyToOne等）を確認
     - 検証ルール（@NotNull, @Size等のアノテーション）を確認
   - **第二参照**: functional_design.md
     - クラス設計、属性名、メソッドシグネチャを確認
     - ビジネスロジックメソッド（calculateTotal等）があれば実装
   - **並行制御**: architecture_design.mdの「7. 並行制御」で楽観的ロック（@Version）の使用を確認
   
   **Repository/Dao生成時**:
   - **技術スタック**: architecture_design.mdの「1.2 Jakarta EE仕様」でJakarta Persistence（JPA）とCDIバージョンを確認
   - **スコープ**: architecture_design.mdの「5. 状態管理」で@ApplicationScopedを使用
   - **第一参照**: functional_design.md
     - Dao/Repositoryインターフェース、メソッドシグネチャ、戻り値の型を確認
     - クエリメソッドの動作仕様（検索条件、ソート順、結合条件）を確認
   - **第二参照**: data_model.md
     - SQLクエリ設計の参考（テーブル名、カラム名、結合条件）
     - インデックスやパフォーマンス考慮事項を確認
   
   **Service層生成時**:
   - **技術スタック**: architecture_design.mdの「1.2 Jakarta EE仕様」でJakarta CDI, Transactionsバージョンを確認
   - **スコープ**: architecture_design.mdの「5. 状態管理」で@ApplicationScopedを使用
   - **トランザクション**: architecture_design.mdの「6. トランザクション管理」で@Transactionalの使用方法を確認
   - **第一参照**: functional_design.md
     - Serviceクラスのメソッドシグネチャ、ビジネスロジック、処理フローを確認
     - トランザクション境界、例外ハンドリング、バリデーションロジックを確認
   - **第二参照**: behaviors.md
     - 各メソッドの振る舞い（Given-When-Then）、業務ルール、制約条件を確認
     - エッジケースや異常系の処理を確認
   - **例外処理**: architecture_design.mdの「8. エラーハンドリング方針」に従う
   
   **Controller/Bean生成時**:
   - **技術スタック**: architecture_design.mdの「1.2 Jakarta EE仕様」でJakarta Faces（JSF）バージョンを確認
   - **スコープ**: architecture_design.mdの「5. 状態管理」で適切なスコープ（@ViewScoped, @SessionScoped等）を選択
   - **第一参照**: functional_design.md
     - Controller/Beanクラスの設計、メソッド、画面遷移ロジックを確認
     - リクエストパラメータ、バリデーション、エラーハンドリングを確認
   - **第二参照**: screen_design.md
     - 画面遷移フロー、パラメータ受け渡し、データバインディングを確認
     - フォーム入力項目、バリデーションルールを確認
   - **Serializableの実装**: @ViewScoped, @SessionScopedの場合は必須（architecture_design.mdの「5. 状態管理」参照）
   
   **View/UI生成時**:
   - **技術スタック**: architecture_design.mdの「1.2 Jakarta EE仕様」でJakarta Faces（Facelets XHTML）を確認
   - **第一参照**: screen_design.md
     - レイアウト構成、UI要素（ボタン、フォーム、テーブル等）、デザイン仕様を確認
     - 画面表示項目、入力フィールド、必須項目マーク、エラーメッセージ表示位置を確認
     - カラースキーム、レスポンシブブレークポイント、アクセシビリティ要件を確認
   - **第二参照**: functional_design.md
     - データバインディング（バッキングビーンのプロパティ名）を確認
     - イベントハンドラー（ボタンクリック時のメソッド名）を確認
   
   **外部連携コンポーネント生成時**:
   - **技術スタック**: architecture_design.mdの「1.3 追加ライブラリ」でJakarta REST Clientの使用を確認
   - **第一参照**: external_interface.md
     - API仕様（エンドポイント、HTTPメソッド、リクエスト/レスポンス形式）を確認
     - OpenAPI YAMLファイルがあれば、スキーマ定義、認証方式、エラーレスポンスを確認
     - 通信プロトコル、タイムアウト設定、リトライポリシーを確認
   - **第二参照**: functional_design.md
     - 連携クラスの設計、メソッド名、エラーハンドリングを確認
   
   **E2Eテスト生成時（Playwright）**:
   - **第一参照**: screen_design.md
     - 画面遷移図（Mermaid stateDiagram）から主要なユーザーフローを抽出
     - 各画面のUI要素（ボタン、フォーム、リンク等）と配置を確認
     - 画面ID、ファイル名、認証要否を確認してテストシナリオを構築
   - **第二参照**: behaviors.md
     - Given-When-Thenシナリオを画面操作シーケンスに変換
     - エラーケース（在庫不足、認証失敗等）の画面表示を確認
   - **第三参照**: functional_design.md
     - 画面遷移時のデータの流れ、セッション管理を確認
     - 各画面のバッキングビーンとメソッドの対応を確認

6. ドキュメント参照の基本方針：
   - **architecture_design.md**: 技術スタック、アーキテクチャパターン、品質基準など、プロジェクト全体の技術的指針を提供
   - **functional_design.md**: 具体的なクラス設計、メソッドシグネチャ、ビジネスロジックなど、実装レベルの詳細を提供
   - **各コンポーネントの参照方法**: 上記5番のセクションを参照

7. 進捗追跡とエラーハンドリング：
   - 完了した各タスク後に進捗を報告
   - 順次実行タスクが失敗した場合は実行を停止
   - 並列実行タスク[P]の場合、成功したタスクを続行し、失敗したタスクを報告
   - デバッグのためのコンテキスト付きの明確なエラーメッセージを提供
   - 実装を続行できない場合は次の手順を提案
   - **重要**: 完了したタスクについては、tasks.mdファイルでタスクを[X]としてマーク

8. 完了検証：
   - 憲章の原則と品質基準が遵守されていることを確認
   - 全ての必須タスクが完了していることを確認
   - 実装された機能が要件定義と一致することを確認
   - テストがパスし、カバレッジが要件を満たすことを検証
   - 実装がアーキテクチャ設計に従っていることを確認
   - クラス設計が機能設計仕様と一致することを検証
   - **仕様書とのトレーサビリティ検証**:
     - behaviors.mdの受入基準（Given-When-Then）が全てテストケースでカバーされていることを確認
     - screen_design.mdで定義された全てのUI要素（ボタン、フォーム、テーブル等）が実装されていることを確認
     - screen_design.mdの画面遷移図の全ての主要パスがE2Eテスト（Playwright）でカバーされていることを確認
     - data_model.mdで定義された全ての制約条件（NOT NULL, UNIQUE, FK等）が実装されていることを確認
     - functional_design.mdで定義された全てのクラス、メソッドが実装されていることを確認
     - external_interface.mdで定義された全てのAPI仕様が実装されていることを確認
   - 画像リソースが正しく配置されていることを確認（`<プロジェクトルート>/images/covers/` → `<プロジェクトルート>/src/main/webapp/resources/covers/`）
   - 完了した作業の要約とともに最終ステータスを報告
   - **このタスクファイルのタスクがすべて完了したら、ここで停止する**

注意: 
- このインストラクションは、タスクリストに完全なタスク分解が存在することを前提としています。タスクが不完全または欠落している場合は、まず `@instructions/generate_tasks.md` を使用してタスクリストを生成することを提案してください。
- **指定されたタスクファイルのタスクのみを実行してください。他のタスクファイル（例: 次の機能のタスク）に自動的に進んではいけません。**
- タスクは分業の単位です。1つのタスクが完了したら、次のタスクに進む前にユーザーの確認を待ってください。

